<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · XAMAuxData.jl</title><meta name="title" content="Home · XAMAuxData.jl"/><meta property="og:title" content="Home · XAMAuxData.jl"/><meta property="twitter:title" content="Home · XAMAuxData.jl"/><meta name="description" content="Documentation for XAMAuxData.jl."/><meta property="og:description" content="Documentation for XAMAuxData.jl."/><meta property="twitter:description" content="Documentation for XAMAuxData.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>XAMAuxData.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Core-concepts"><span>Core concepts</span></a></li><li><a class="tocitem" href="#Constructing-Auxiliary-objects"><span>Constructing <code>Auxiliary</code> objects</span></a></li><li><a class="tocitem" href="#Manipulating-Auxiliary-objects"><span>Manipulating <code>Auxiliary</code> objects</span></a></li><li><a class="tocitem" href="#More-details-about-element-type"><span>More details about element type</span></a></li><li><a class="tocitem" href="#Writing-Auxiliarys-to-files"><span>Writing <code>Auxiliary</code>s to files</span></a></li><li><a class="tocitem" href="#Invalid-data-in-Auxiliaries"><span>Invalid data in <code>Auxiliaries</code></span></a></li></ul></li><li><a class="tocitem" href="reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="XAMAuxData.jl"><a class="docs-heading-anchor" href="#XAMAuxData.jl">XAMAuxData.jl</a><a id="XAMAuxData.jl-1"></a><a class="docs-heading-anchor-permalink" href="#XAMAuxData.jl" title="Permalink"></a></h1><p>This package contains functionality to parse the auxiliary (optional) fields in the SAM and BAM format. The formats PAF and GFA (and possibly others) share this same mini-format of SAM aux fields. This package is intended to be used by other packages, such as XAM.jl and other parsing packages.</p><h2 id="Core-concepts"><a class="docs-heading-anchor" href="#Core-concepts">Core concepts</a><a id="Core-concepts-1"></a><a class="docs-heading-anchor-permalink" href="#Core-concepts" title="Permalink"></a></h2><p>XAMAuxData has two submodules - <code>SAM</code> and <code>BAM</code>. <code>SAM</code> is used for the text-based auxiliary format in SAM, PAF and GFA files. <code>BAM</code> is used for the binary encoded aux format in BAM files. Most examples in this documentation will use the SAM format, since it&#39;s more human readable. Any differences to the BAM format will be explicitly mentioned.</p><div class="admonition is-info" id="Note-3c1a951659cfd84"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-3c1a951659cfd84" title="Permalink"></a></header><div class="admonition-body"><p>Annoyingly, the specification of GFA auxiliary fields differ slightly from that of SAM auxiliary fields. Currently, this package implements only the SAM specification, and as such does not fully support GFA files. In the future, a dedicated GFA module may be introduced.</p></div></div><p>The single auxiliary field <code>AN:i:1234</code> is encoded as the key-value pair <code>AuxTag(&quot;AN&quot;) =&gt; 1234</code>. A collection of aux fields are represented by a <code>SAM.Auxiliary</code> (or <code>BAM.Auxiliary</code>), which are subtypes of <code>AbstractDict{AuxTag, Any}</code>.</p><p>The package may be used like this:</p><pre><code class="language-julia-repl hljs"># Import the module you want to use
julia&gt; using XAMAuxData: SAM

julia&gt; data = &quot;AN:A:z\ta1:Z:abc def \tkv:i:-25234\tzz:f:-14.466e-3&quot;;

julia&gt; aux = SAM.Auxiliary(data)
4-element XAMAuxData.SAM.Auxiliary{MemoryViews.ImmutableMemoryView{UInt8}}:
  &quot;AN&quot; =&gt; &#39;z&#39;
  &quot;a1&quot; =&gt; &quot;abc def &quot;
  &quot;kv&quot; =&gt; -25234
  &quot;zz&quot; =&gt; -0.014466f0</code></pre><h4 id="The-AuxTag-object"><a class="docs-heading-anchor" href="#The-AuxTag-object">The <code>AuxTag</code> object</a><a id="The-AuxTag-object-1"></a><a class="docs-heading-anchor-permalink" href="#The-AuxTag-object" title="Permalink"></a></h4><p>The keys of an <code>Auxiliary</code> are instances of <code>AuxTag</code>. Why not simply have them be two-byte strings? <code>AuxTags</code> are compact bitstypes and therefore not heap-allocated for extra performance. Also, the construction of an <code>AugTax</code> validates that it conforms to the regex <code>[A-Za-z][A-Za-z0-9]</code> per the SAM specs.</p><p>Strings can be converted to <code>AuxTag</code> for convenience, as in below:</p><pre><code class="language-julia-repl hljs">julia&gt; push!(AuxTag[], &quot;AB&quot;) # implicit conversion
1-element Vector{AuxTag}:
 AuxTag(&quot;AB&quot;)</code></pre><p>Attempting to construct an invalid <code>AuxTag</code> will error:</p><pre><code class="language-julia-repl hljs">julia&gt; AuxTag(&quot;11&quot;)
ERROR: Invalid AuxTag. Tags must conform to r&quot;^[A-Za-z][A-Za-z0-9]$&quot;.
[...]</code></pre><h2 id="Constructing-Auxiliary-objects"><a class="docs-heading-anchor" href="#Constructing-Auxiliary-objects">Constructing <code>Auxiliary</code> objects</a><a id="Constructing-Auxiliary-objects-1"></a><a class="docs-heading-anchor-permalink" href="#Constructing-Auxiliary-objects" title="Permalink"></a></h2><p><code>SAM.Auxiliary</code> and <code>BAM.Auxiliary</code> are constructed the same two ways.</p><p>Immutable auxiliaries are constructed from any bytes-like object which has a <code>MemoryView</code> method. This may be a <code>String</code>, <code>SubString{String}</code>, <code>Memory{UInt8}</code> etc. Auxiliary objects are constructed directly from these:</p><pre><code class="language-julia-repl hljs"># Make an IMMUTABLE Auxiliary
julia&gt; aux = SAM.Auxiliary(&quot;AB:i:12\tKN:A:z&quot;)
2-element XAMAuxData.SAM.Auxiliary{MemoryViews.ImmutableMemoryView{UInt8}}:
  &quot;AB&quot; =&gt; 12
  &quot;KN&quot; =&gt; &#39;z&#39;</code></pre><p>In order to mutate auxiliary objects, their data need to be able to be resized, and therefore must be backed by a <code>Vector{UInt8}</code>. Mutable auxiliaries can be constructed from a <code>Vector{UInt8}</code> and a starting index. Any data before the starting index is never touched by the <code>Auxiliary</code> object, even if e.g. the object is emptied. This starting index enables <code>Auxiliary</code> objects to share the same <code>Vector</code> that is used to store other data of PAF, SAM or GFA records.</p><p>In the example below, the first 22 bytes of the vector (the <code>some not-aux data here</code> part) corresponds to the data before the aux data, and hence the first index of the aux data in the vector is 23.</p><pre><code class="language-julia-repl hljs">julia&gt; data = collect(codeunits(&quot;some not-aux data hereAB:i:12\tKN:A:z&quot;));

julia&gt; aux = SAM.Auxiliary(data, 23) # Make a MUTABLE Auxiliary
2-element XAMAuxData.SAM.Auxiliary{Vector{UInt8}}:
  &quot;AB&quot; =&gt; 12
  &quot;KN&quot; =&gt; &#39;z&#39;</code></pre><p>No matter whether constructed from a memory view or from a <code>Vector</code>, there cannot be any unused bytes at or after the starting index in an <code>Auxiliary</code>. Any trailing bytes will be considered part of the auxiliary data, and may possibly be considered invalid:</p><pre><code class="language-julia-repl hljs">julia&gt; bad_aux = SAM.Auxiliary(&quot;AB:A:p\t\t&quot;); # trailing tabs

julia&gt; isvalid(bad_aux)
false</code></pre><h2 id="Manipulating-Auxiliary-objects"><a class="docs-heading-anchor" href="#Manipulating-Auxiliary-objects">Manipulating <code>Auxiliary</code> objects</a><a id="Manipulating-Auxiliary-objects-1"></a><a class="docs-heading-anchor-permalink" href="#Manipulating-Auxiliary-objects" title="Permalink"></a></h2><p><code>Auxiliary</code>s can be read and written like a normal <code>AbstractDict{AuxTag, Any}</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; aux = SAM.Auxiliary(UInt8[], 1); # empty Auxiliary

julia&gt; # Note: The strings are implicitly `convert`ed to AuxTag
       aux[&quot;AX&quot;] = &#39;y&#39;; aux[&quot;AX&quot;]
&#39;y&#39;: ASCII/Unicode U+0079 (category Ll: Letter, lowercase)

julia&gt; aux[&quot;cm&quot;] = 12.1; aux[&quot;cm&quot;]
12.1f0

julia&gt; aux[&quot;G1&quot;] = [-1.24, 33.1]; aux[&quot;G1&quot;]
2-element Memory{Float32}:
 -1.24
 33.1

julia&gt; aux[&quot;AX&quot;] = [0x01, 0x02]; aux[&quot;AX&quot;] # overwrite AX key
2-element Memory{UInt8}:
 0x01
 0x02</code></pre><p>Like <code>Dict</code>, the order of key/value pairs in auxiliaries is arbitrary and cannot be relied on.</p><h2 id="More-details-about-element-type"><a class="docs-heading-anchor" href="#More-details-about-element-type">More details about element type</a><a id="More-details-about-element-type-1"></a><a class="docs-heading-anchor-permalink" href="#More-details-about-element-type" title="Permalink"></a></h2><p>The SAM and BAM formats support only support a limited set of types, and the supported types differ between SAM and BAM. When writing a value to an <code>Auxiliary</code> object, this package will attempt to convert your value to one of the supported types. Hence, the value written to an <code>Auxiliary</code> may not be the same value when being read back.</p><h3 id="Reading:-SAM-element-types"><a class="docs-heading-anchor" href="#Reading:-SAM-element-types">Reading: SAM element types</a><a id="Reading:-SAM-element-types-1"></a><a class="docs-heading-anchor-permalink" href="#Reading:-SAM-element-types" title="Permalink"></a></h3><table><tr><th style="text-align: right">SAM type</th><th style="text-align: right">Julia type read</th></tr><tr><td style="text-align: right"><code>i</code></td><td style="text-align: right"><code>Int</code></td></tr><tr><td style="text-align: right"><code>A</code></td><td style="text-align: right"><code>Char</code></td></tr><tr><td style="text-align: right"><code>f</code></td><td style="text-align: right"><code>Float32</code></td></tr><tr><td style="text-align: right"><code>Z</code></td><td style="text-align: right"><code>StringView</code>*</td></tr><tr><td style="text-align: right"><code>H</code></td><td style="text-align: right"><code>Memory{UInt8}</code></td></tr><tr><td style="text-align: right"><code>B:C</code></td><td style="text-align: right"><code>Memory{UInt8}</code></td></tr><tr><td style="text-align: right"><code>B:c</code></td><td style="text-align: right"><code>Memory{Int8}</code></td></tr><tr><td style="text-align: right"><code>B:S</code></td><td style="text-align: right"><code>Memory{UInt16}</code></td></tr><tr><td style="text-align: right"><code>B:s</code></td><td style="text-align: right"><code>Memory{Int8}</code></td></tr><tr><td style="text-align: right"><code>B:I</code></td><td style="text-align: right"><code>Memory{UInt32}</code></td></tr><tr><td style="text-align: right"><code>B:i</code></td><td style="text-align: right"><code>Memory{Int32}</code></td></tr><tr><td style="text-align: right"><code>B:f</code></td><td style="text-align: right"><code>Memory{Float32}</code></td></tr></table><ul><li>This is a parametric type. The precise concrete type depends on the type the view looks into, and is an implementation detail.</li></ul><h3 id="Writing:-SAM-element-types"><a class="docs-heading-anchor" href="#Writing:-SAM-element-types">Writing: SAM element types</a><a id="Writing:-SAM-element-types-1"></a><a class="docs-heading-anchor-permalink" href="#Writing:-SAM-element-types" title="Permalink"></a></h3><table><tr><th style="text-align: right">Input type</th><th style="text-align: right">SAM type stored</th></tr><tr><td style="text-align: right"><code>Integer</code>*</td><td style="text-align: right"><code>i</code></td></tr><tr><td style="text-align: right"><code>AbstractChar</code>✝</td><td style="text-align: right"><code>A</code></td></tr><tr><td style="text-align: right"><code>AbstractFloat</code>‡</td><td style="text-align: right"><code>f</code></td></tr><tr><td style="text-align: right"><code>AbstractString</code>§</td><td style="text-align: right"><code>Z</code></td></tr><tr><td style="text-align: right"><code>AbstractVector{UInt8}</code></td><td style="text-align: right"><code>B:C</code></td></tr><tr><td style="text-align: right"><code>AbstractVector{Int8}</code></td><td style="text-align: right"><code>B:c</code></td></tr><tr><td style="text-align: right"><code>AbstractVector{UInt16}</code></td><td style="text-align: right"><code>B:S</code></td></tr><tr><td style="text-align: right"><code>AbstractVector{Int16}</code></td><td style="text-align: right"><code>B:s</code></td></tr><tr><td style="text-align: right"><code>AbstractVector{&lt;:Signed}</code>¶</td><td style="text-align: right"><code>B:i</code></td></tr><tr><td style="text-align: right"><code>AbstractVector{&lt;:Unsigned}</code>¶</td><td style="text-align: right"><code>B:I</code></td></tr><tr><td style="text-align: right"><code>AbstractVector{&lt;:AbstractFloat}</code>‡</td><td style="text-align: right"><code>B:f</code></td></tr><tr><td style="text-align: right"><code>Hex</code></td><td style="text-align: right"><code>H</code></td></tr></table><ul><li><code>*</code> Only values in <code>typemin(Int32):typemax(Int32)</code> are allowed. This is because the SAM specs recommend to limit yourselves to this range of values. However, when reading <code>i</code> fields, an <code>Int</code> is returned, such that values outside the recommended range can still be read on 64-bit systems.</li><li>✝ Permitted <code>Char</code> values are only those in <code>&#39;!&#39;:&#39;~&#39;</code>.</li><li>‡ Only values representable by a <code>Float32</code> are allowed.</li><li>§ Only characters in <code>&#39;!&#39;:&#39;~&#39;</code> and spaces (<code>&#39; &#39;</code>) are permitted in strings</li><li>¶ These are stored as <code>Int32</code> and <code>UInt32</code> for <code>Signed</code> and <code>Unsigned</code>, respectively.</li></ul><h3 id="BAM-element-types"><a class="docs-heading-anchor" href="#BAM-element-types">BAM element types</a><a id="BAM-element-types-1"></a><a class="docs-heading-anchor-permalink" href="#BAM-element-types" title="Permalink"></a></h3><h4 id="BAM-integers"><a class="docs-heading-anchor" href="#BAM-integers">BAM integers</a><a id="BAM-integers-1"></a><a class="docs-heading-anchor-permalink" href="#BAM-integers" title="Permalink"></a></h4><p>The main difference between SAM and BAM types is that the latter format permits different types of integers. Hence, except the types mentioned below, all the SAM types in the table above are also supported in BAM, with the same Julia &lt;-&gt; BAM type correspondance. Further, reading a value of <code>i</code> will return an <code>Int32</code> instead of an <code>Int</code>.</p><table><tr><th style="text-align: right">Input type</th><th style="text-align: right">BAM type</th><th style="text-align: right">Julia type read</th></tr><tr><td style="text-align: right"><code>UInt8</code></td><td style="text-align: right"><code>C</code></td><td style="text-align: right"><code>UInt8</code></td></tr><tr><td style="text-align: right"><code>Int8</code></td><td style="text-align: right"><code>c</code></td><td style="text-align: right"><code>Int8</code></td></tr><tr><td style="text-align: right"><code>UInt16</code></td><td style="text-align: right"><code>S</code></td><td style="text-align: right"><code>UInt16</code></td></tr><tr><td style="text-align: right"><code>Int16</code></td><td style="text-align: right"><code>s</code></td><td style="text-align: right"><code>Int16</code></td></tr><tr><td style="text-align: right"><code>Unsigned</code></td><td style="text-align: right"><code>I</code></td><td style="text-align: right"><code>UInt32</code></td></tr><tr><td style="text-align: right"><code>Signed</code></td><td style="text-align: right"><code>i</code></td><td style="text-align: right"><code>Int32</code></td></tr></table><h4 id="BAM-Arrays"><a class="docs-heading-anchor" href="#BAM-Arrays">BAM Arrays</a><a id="BAM-Arrays-1"></a><a class="docs-heading-anchor-permalink" href="#BAM-Arrays" title="Permalink"></a></h4><p>Whereas reading a SAM array (type <code>B</code>) will result in a <code>Memory</code>, BAM arrays only promise that they return an <code>AbstractVector</code> of the correct element type:</p><pre><code class="language-julia-repl hljs">julia&gt; aux = BAM.Auxiliary(&quot;ABBs\2\0\0\0\1\2\3\4&quot;);

julia&gt; aux[&quot;AB&quot;] isa AbstractVector{Int16}
true</code></pre><h3 id="The-Hex-type"><a class="docs-heading-anchor" href="#The-Hex-type">The <code>Hex</code> type</a><a id="The-Hex-type-1"></a><a class="docs-heading-anchor-permalink" href="#The-Hex-type" title="Permalink"></a></h3><p>The SAM/BAM type <code>H</code> signifies a hex-encoded byte array. Byte arrays are stored as the <code>B:C</code> type when written, since this type is more legible (in SAM), and more space efficient in BAM. Therefore, the <code>B:C</code> type is generally recommended over the <code>H</code> type when writing byte arrays. However, if you want to write an <code>AbstractVector{UInt8}</code> value explicitly as an <code>H</code> type, wrap it in the <code>Hex</code> type:</p><pre><code class="language-julia hljs">aux = SAM.Auxiliary(UInt8[], 1)
aux[&quot;AB&quot;] = UInt8[0x01, 0x02]

using MemoryViews
# Print the memory content of the aux.
# The array was written as a value of the type B:c
println(String(MemoryView(aux)))

# Wrap input type in the Hex type
aux[&quot;AB&quot;] = Hex(UInt8[0x01, 0x02])

# It is now written as a H instead
println(String(MemoryView(aux)))

# output
AB:B:C,1,2
AB:H:0102</code></pre><h2 id="Writing-Auxiliarys-to-files"><a class="docs-heading-anchor" href="#Writing-Auxiliarys-to-files">Writing <code>Auxiliary</code>s to files</a><a id="Writing-Auxiliarys-to-files-1"></a><a class="docs-heading-anchor-permalink" href="#Writing-Auxiliarys-to-files" title="Permalink"></a></h2><p>Calling <code>MemoryView</code> on an <code>Auxiliary</code> will return a view of the underlying data. This data is guaranteed to be valid SAM/BAM auxiliary data:</p><pre><code class="language-julia hljs">(field1, field2) = (&quot;PG:A:n&quot;, &quot;ca:i:-241&quot;)
aux = SAM.Auxiliary(field1 * &#39;\t&#39; * field2)

# Get a view of the data underlying `aux`.
# This is guaranteed to be valid SAM data (and likewise for BAM)
using MemoryViews
mem = MemoryView(aux)

# We make no guarantees about which order the two fields are,
# but we DO guarantee the memory is a valid SAM aux data
# with these two fields
println(
  in(
    String(mem),
    (field1 * &#39;\t&#39; * field2, field2 * &#39;\t&#39; * field1)
  )
)

# output
true
</code></pre><h2 id="Invalid-data-in-Auxiliaries"><a class="docs-heading-anchor" href="#Invalid-data-in-Auxiliaries">Invalid data in <code>Auxiliaries</code></a><a id="Invalid-data-in-Auxiliaries-1"></a><a class="docs-heading-anchor-permalink" href="#Invalid-data-in-Auxiliaries" title="Permalink"></a></h2><p>The elements of an <code>Auxiliary</code> are lazily loaded, and in the interest of speed, there is no mandatory validation of the data done when constructing an <code>Auxiliary</code>. Hence, they may contain invalid data. This package distinguishes two different kinds of bad data:</p><ol><li><p>If the data is malformed in such a way that it&#39;s not possible to identify the keys of the auxiliary, or the data segment of the corresponding values, we say the auxiliary is malformed. Loading keys or values from malformed auxiliaries <em>may</em> throw an exception. The function <a href="reference/#XAMAuxData.is_well_formed"><code>is_well_formed</code></a> can be used to check for malformed auxiliaries.</p></li><li><p>If the keys and the data segments corresponding to the values <em>can</em> be identified, but the data itself is corrupt such that the values cannot be loaded, we instead say the auxiliary is invalid. Loading an invalid value return an object of type <a href="reference/#XAMAuxData.Errors.Error"><code>Error</code></a>. The validity of an auxiliary can be checked with <code>isvalid</code>. All valid records are also well-formed.</p></li></ol><p>For example:</p><pre><code class="language-julia-repl hljs">julia&gt; # This is completely mangled

julia&gt; aux = SAM.Auxiliary(&quot;erwlifju093&quot;);

julia&gt; (is_well_formed(aux), isvalid(aux))
(false, false)

julia&gt; # Keys and values can be identified, but data can&#39;t be loaded as an integer

julia&gt; aux = SAM.Auxiliary(&quot;AB:i:dslkjas&quot;);

julia&gt; (is_well_formed(aux), isvalid(aux))
(true, false)

julia&gt; only(values(aux)) isa Error
true</code></pre></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="reference/">Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Saturday 18 October 2025 14:49">Saturday 18 October 2025</span>. Using Julia version 1.12.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
